# 데이터 컴포넌트 분리 가이드

## 개요

데이터 컴포넌트는 UI 컴포넌트에 데이터를 전달하기 위한 계층으로, 데이터를 가져와서 가공하는 역할을 담당합니다. 이 문서는 UI와 데이터 로직을 분리하여 관심사를 명확히 나누고, 재사용성과 테스트 용이성을 향상시키는 방법을 설명합니다.

## 데이터 컴포넌트란?

### 정의
데이터 컴포넌트는 다음과 같은 역할을 담당하는 컴포넌트입니다:
- **데이터 가져오기**: API 호출, 상태 관리, 외부 데이터 소스 접근
- **데이터 가공**: 원본 데이터를 UI에서 사용할 수 있는 형태로 변환
- **비즈니스 로직**: 도메인 규칙, 유효성 검사, 계산 로직
- **상태 관리**: 컴포넌트 내부 상태 관리 및 업데이트

### UI 컴포넌트와의 차이점

| 구분 | 데이터 컴포넌트 | UI 컴포넌트 |
|------|----------------|-------------|
| **역할** | 데이터 처리 및 비즈니스 로직 | 순수한 표현 |
| **Props** | 최소한의 props (이벤트 핸들러) | 모든 데이터를 props로 받음 |
| **상태** | 내부 상태 관리 | 상태 없음 (순수 함수) |
| **재사용성** | 도메인 특화 | 높은 재사용성 |
| **테스트** | 비즈니스 로직 테스트 | 렌더링 테스트 |

## 네이밍 컨벤션

### 컴포넌트 네이밍 규칙

데이터 컴포넌트와 UI 컴포넌트를 명확히 구분하기 위해 다음과 같은 네이밍 컨벤션을 사용합니다:

#### 데이터 컴포넌트: `[ComponentName]Container`
- **역할**: 데이터 가져오기, 가공, 비즈니스 로직 처리
- **예시**: `ProductCardContainer`, `ProductsFormContainer`, `ProductsTableContainer`, `CartPageContainer`

#### UI 컴포넌트: `[ComponentName]UI`
- **역할**: 순수한 표현, 데이터 표시
- **예시**: `ProductCardUI`, `ProductsFormUI`, `ProductsTableUI`, `CartPageUI`

#### 파일 구조
```
components/
├── [component-name]/
│   ├── [ComponentName]Container.tsx  # 데이터 컴포넌트
│   ├── [ComponentName]UI.tsx         # UI 컴포넌트
│   └── index.ts                      # 내보내기 (선택사항)
```

#### 사용 예시
```tsx
// 데이터 컴포넌트 사용
import { ProductCardContainer } from './components/ProductCardContainer';

// UI 컴포넌트는 직접 사용하지 않음 (Container를 통해 사용)
// import { ProductCardUI } from './components/ProductCardUI'; // ❌ 직접 사용 금지
```

## 분리 패턴

### 1. Container/Presentational 패턴

```tsx
// 데이터 컴포넌트 (Container)
const ProductCardContainer = () => {
  const { product, addToCart } = useProduct();
  const { formatPrice, calculateDiscount } = useFormatters();
  
  const handleAddToCart = () => {
    addToCart(product.id);
  };
  
  const processedData = {
    name: product.name,
    price: formatPrice(product.price),
    discountRate: calculateDiscount(product.price, product.originalPrice),
    stockStatus: getStockStatus(product.stock),
    remainingStock: product.stock
  };
  
  return <ProductCardUI {...processedData} onAddToCart={handleAddToCart} />;
};

// UI 컴포넌트 (Presentational)
const ProductCardUI = ({ 
  name, 
  price, 
  discountRate, 
  stockStatus, 
  remainingStock, 
  onAddToCart 
}: ProductCardUIProps) => {
  return (
    <Card>
      <h3>{name}</h3>
      <p>{price}</p>
      {discountRate && <Badge>{discountRate}</Badge>}
      <Button onClick={onAddToCart}>장바구니 추가</Button>
    </Card>
  );
};
```

### 2. Custom Hook 패턴

```tsx
// 데이터 로직을 Custom Hook으로 분리
const useProductCard = (productId: string) => {
  const { product, addToCart } = useProduct();
  const { formatPrice, calculateDiscount } = useFormatters();
  
  const handleAddToCart = useCallback(() => {
    addToCart(productId);
  }, [productId, addToCart]);
  
  const processedData = useMemo(() => ({
    name: product.name,
    price: formatPrice(product.price),
    discountRate: calculateDiscount(product.price, product.originalPrice),
    stockStatus: getStockStatus(product.stock),
    remainingStock: product.stock
  }), [product]);
  
  return {
    ...processedData,
    onAddToCart: handleAddToCart
  };
};

// 데이터 컴포넌트
const ProductCardContainer = ({ productId }: { productId: string }) => {
  const productData = useProductCard(productId);
  return <ProductCardUI {...productData} />;
};
```

## 구현 가이드

### 1. 데이터 컴포넌트 설계 원칙

#### 단일 책임 원칙
```tsx
// ❌ 잘못된 예: 너무 많은 책임
const ProductCard = () => {
  const [products, setProducts] = useState([]);
  const [cart, setCart] = useState([]);
  const [user, setUser] = useState(null);
  
  // 제품 데이터 가져오기
  useEffect(() => {
    fetchProducts().then(setProducts);
  }, []);
  
  // 장바구니 데이터 가져오기
  useEffect(() => {
    fetchCart().then(setCart);
  }, []);
  
  // 사용자 데이터 가져오기
  useEffect(() => {
    fetchUser().then(setUser);
  }, []);
  
  // UI 렌더링까지 담당
  return <div>...</div>;
};

// ✅ 올바른 예: 단일 책임
const ProductCard = ({ productId }: { productId: string }) => {
  const productData = useProduct(productId);
  const cartData = useCart();
  
  const handleAddToCart = useCallback(() => {
    cartData.addToCart(productId);
  }, [productId, cartData]);
  
  return <ProductCardUI {...productData} onAddToCart={handleAddToCart} />;
};
```

#### 데이터 변환 분리
```tsx
// ❌ 잘못된 예: UI 컴포넌트에서 데이터 변환
const ProductCardUI = ({ product }: { product: Product }) => {
  const price = formatPrice(product.price);
  const discountRate = calculateDiscount(product.price, product.originalPrice);
  
  return (
    <div>
      <span>{price}</span>
      {discountRate && <span>{discountRate}% 할인</span>}
    </div>
  );
};

// ✅ 올바른 예: 데이터 컴포넌트에서 변환
const ProductCard = ({ product }: { product: Product }) => {
  const processedData = {
    price: formatPrice(product.price),
    discountRate: calculateDiscount(product.price, product.originalPrice),
    stockStatus: getStockStatus(product.stock)
  };
  
  return <ProductCardUI {...processedData} />;
};
```

### 2. Props 설계

#### UI 컴포넌트 Props 설계
```tsx
interface ProductCardUIProps {
  // 데이터 (가공된 형태)
  name: string;
  price: string; // 이미 포맷된 가격
  discountRate?: string; // 이미 계산된 할인율
  stockStatus: 'sufficient' | 'low' | 'out';
  remainingStock: number;
  
  // 이벤트 핸들러
  onAddToCart: () => void;
  onViewDetails?: () => void;
  
  // UI 옵션
  variant?: 'default' | 'compact';
  showStock?: boolean;
}
```

#### 데이터 컴포넌트 Props 설계
```tsx
interface ProductCardContainerProps {
  // 식별자
  productId: string;
  
  // 옵션
  variant?: 'default' | 'compact';
  showStock?: boolean;
  
  // 콜백
  onAddToCartSuccess?: () => void;
  onError?: (error: Error) => void;
}
```

### 3. 상태 관리

#### 로컬 상태 관리
```tsx
const ProductCardContainer = ({ productId }: { productId: string }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const { product, addToCart } = useProduct(productId);
  
  const handleAddToCart = async () => {
    try {
      setIsLoading(true);
      setError(null);
      await addToCart(productId);
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  };
  
  if (error) {
    return <ErrorCard error={error} onRetry={() => setError(null)} />;
  }
  
  return (
    <ProductCardUI 
      {...product} 
      onAddToCart={handleAddToCart}
      isLoading={isLoading}
    />
  );
};
```

#### 전역 상태와의 연동
```tsx
const ProductCardContainer = ({ productId }: { productId: string }) => {
  const { product } = useProduct(productId);
  const { cart, addToCart } = useCart();
  const { notifications, showNotification } = useNotifications();
  
  const isInCart = cart.items.some(item => item.productId === productId);
  
  const handleAddToCart = () => {
    addToCart(productId);
    showNotification('장바구니에 추가되었습니다.', 'success');
  };
  
  return (
    <ProductCardUI 
      {...product}
      isInCart={isInCart}
      onAddToCart={handleAddToCart}
    />
  );
};
```

## 실제 구현 예시

### 1. ProductCard 분리 예시

#### 데이터 컴포넌트 (`ProductCardContainer.tsx`)
```tsx
import { useProduct } from '@/hooks/useProduct';
import { useCart } from '@/hooks/useCart';
import { useFormatters } from '@/utils/formatters';
import { ProductCardUI } from './ProductCardUI';

interface ProductCardContainerProps {
  productId: string;
  variant?: 'default' | 'compact';
  showStock?: boolean;
}

export const ProductCardContainer = ({ 
  productId, 
  variant = 'default', 
  showStock = true 
}: ProductCardContainerProps) => {
  const { product, isLoading, error } = useProduct(productId);
  const { addToCart, isAddingToCart } = useCart();
  const { formatPrice, calculateDiscount } = useFormatters();
  
  const handleAddToCart = useCallback(() => {
    addToCart(productId);
  }, [productId, addToCart]);
  
  const processedData = useMemo(() => {
    if (!product) return null;
    
    return {
      name: product.name,
      description: product.description,
      price: formatPrice(product.price),
      originalPrice: product.originalPrice ? formatPrice(product.originalPrice) : undefined,
      discountRate: product.originalPrice 
        ? calculateDiscount(product.price, product.originalPrice)
        : undefined,
      stockStatus: getStockStatus(product.stock),
      remainingStock: product.stock,
      imageUrl: product.imageUrl,
      isRecommended: product.isRecommended
    };
  }, [product, formatPrice, calculateDiscount]);
  
  if (isLoading) {
    return <ProductCardSkeleton />;
  }
  
  if (error) {
    return <ProductCardError error={error} />;
  }
  
  if (!processedData) {
    return null;
  }
  
  return (
    <ProductCardUI 
      {...processedData}
      variant={variant}
      showStock={showStock}
      onAddToCart={handleAddToCart}
      isAddingToCart={isAddingToCart}
    />
  );
};
```

#### UI 컴포넌트 (`ProductCardUI.tsx`)
```tsx
import { Card, Badge, Button, Image } from '@/components/ui';

interface ProductCardUIProps {
  name: string;
  description?: string;
  price: string;
  originalPrice?: string;
  discountRate?: string;
  stockStatus: 'sufficient' | 'low' | 'out';
  remainingStock: number;
  imageUrl?: string;
  isRecommended: boolean;
  variant?: 'default' | 'compact';
  showStock?: boolean;
  onAddToCart: () => void;
  isAddingToCart?: boolean;
}

export const ProductCardUI = ({
  name,
  description,
  price,
  originalPrice,
  discountRate,
  stockStatus,
  remainingStock,
  imageUrl,
  isRecommended,
  variant = 'default',
  showStock = true,
  onAddToCart,
  isAddingToCart = false
}: ProductCardUIProps) => {
  const isOutOfStock = stockStatus === 'out';
  
  return (
    <Card variant={variant === 'compact' ? 'compact' : 'default'}>
      {isRecommended && (
        <Badge variant="recommended" className="absolute top-2 right-2">
          추천
        </Badge>
      )}
      
      {imageUrl && (
        <Image 
          src={imageUrl} 
          alt={name}
          className="w-full h-48 object-cover"
        />
      )}
      
      <div className="p-4">
        <h3 className="font-semibold text-lg mb-2">{name}</h3>
        
        {description && variant === 'default' && (
          <p className="text-gray-600 text-sm mb-3">{description}</p>
        )}
        
        <div className="flex items-center gap-2 mb-3">
          <span className="text-xl font-bold">{price}</span>
          {originalPrice && (
            <span className="text-gray-500 line-through text-sm">
              {originalPrice}
            </span>
          )}
          {discountRate && (
            <Badge variant="discount">{discountRate}% 할인</Badge>
          )}
        </div>
        
        {showStock && (
          <div className="mb-3">
            <Badge variant={stockStatus}>
              {stockStatus === 'sufficient' && '재고 충분'}
              {stockStatus === 'low' && `재고 ${remainingStock}개`}
              {stockStatus === 'out' && '품절'}
            </Badge>
          </div>
        )}
        
        <Button
          onClick={onAddToCart}
          disabled={isOutOfStock || isAddingToCart}
          loading={isAddingToCart}
          className="w-full"
        >
          {isOutOfStock ? '품절' : '장바구니 추가'}
        </Button>
      </div>
    </Card>
  );
};
```

### 2. ProductsForm 분리 예시

#### 데이터 컴포넌트 (`ProductsFormContainer.tsx`)
```tsx
import { useState, useCallback } from 'react';
import { useProducts } from '@/hooks/useProducts';
import { useValidation } from '@/utils/hooks/useValidate';
import { ProductsFormUI } from './ProductsFormUI';

interface ProductsFormContainerProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export const ProductsFormContainer = ({ onSuccess, onError }: ProductsFormContainerProps) => {
  const { addProduct, isAdding } = useProducts();
  const { validateProduct } = useValidation();
  
  const [formData, setFormData] = useState({
    name: '',
    price: '',
    description: '',
    category: '',
    stock: ''
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const handleInputChange = useCallback((field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // 실시간 유효성 검사
    const fieldError = validateProduct(field, value);
    setErrors(prev => ({
      ...prev,
      [field]: fieldError || ''
    }));
  }, [validateProduct]);
  
  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    
    // 전체 폼 유효성 검사
    const validationErrors: Record<string, string> = {};
    Object.keys(formData).forEach(field => {
      const error = validateProduct(field, formData[field as keyof typeof formData]);
      if (error) {
        validationErrors[field] = error;
      }
    });
    
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }
    
    try {
      await addProduct({
        name: formData.name,
        price: Number(formData.price),
        description: formData.description,
        category: formData.category,
        stock: Number(formData.stock)
      });
      
      // 폼 초기화
      setFormData({
        name: '',
        price: '',
        description: '',
        category: '',
        stock: ''
      });
      setErrors({});
      
      onSuccess?.();
    } catch (error) {
      onError?.(error as Error);
    }
  }, [formData, addProduct, validateProduct, onSuccess, onError]);
  
  const isFormValid = Object.keys(errors).length === 0 && 
    Object.values(formData).every(value => value.trim() !== '');
  
  return (
    <ProductsFormUI
      formData={formData}
      errors={errors}
      isLoading={isAdding}
      isValid={isFormValid}
      onInputChange={handleInputChange}
      onSubmit={handleSubmit}
    />
  );
};
```

#### UI 컴포넌트 (`ProductsFormUI.tsx`)
```tsx
import { Form, InputWithLabel, SelectWithLabel, Button } from '@/components/ui';

interface ProductsFormUIProps {
  formData: {
    name: string;
    price: string;
    description: string;
    category: string;
    stock: string;
  };
  errors: Record<string, string>;
  isLoading: boolean;
  isValid: boolean;
  onInputChange: (field: string, value: string) => void;
  onSubmit: (e: React.FormEvent) => void;
}

export const ProductsFormUI = ({
  formData,
  errors,
  isLoading,
  isValid,
  onInputChange,
  onSubmit
}: ProductsFormUIProps) => {
  const categories = [
    { value: 'electronics', label: '전자제품' },
    { value: 'clothing', label: '의류' },
    { value: 'books', label: '도서' },
    { value: 'home', label: '홈&리빙' }
  ];
  
  return (
    <Form onSubmit={onSubmit}>
      <FormTitle>새 상품 추가</FormTitle>
      
      <InputWithLabel
        label="상품명"
        value={formData.name}
        onChange={(e) => onInputChange('name', e.target.value)}
        error={errors.name}
        required
      />
      
      <InputWithLabel
        label="가격"
        type="number"
        value={formData.price}
        onChange={(e) => onInputChange('price', e.target.value)}
        error={errors.price}
        required
      />
      
      <InputWithLabel
        label="설명"
        value={formData.description}
        onChange={(e) => onInputChange('description', e.target.value)}
        error={errors.description}
        multiline
      />
      
      <SelectWithLabel
        label="카테고리"
        value={formData.category}
        onChange={(e) => onInputChange('category', e.target.value)}
        error={errors.category}
        options={categories}
        required
      />
      
      <InputWithLabel
        label="재고"
        type="number"
        value={formData.stock}
        onChange={(e) => onInputChange('stock', e.target.value)}
        error={errors.stock}
        required
      />
      
      <div className="flex gap-3 mt-6">
        <Button
          type="submit"
          disabled={!isValid || isLoading}
          loading={isLoading}
        >
          상품 추가
        </Button>
        
        <Button
          type="button"
          variant="secondary"
          onClick={() => window.history.back()}
        >
          취소
        </Button>
      </div>
    </Form>
  );
};
```

## 테스트 전략

### 1. 데이터 컴포넌트 테스트

```tsx
// ProductCardContainer.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ProductCardContainer } from './ProductCardContainer';
import { useProduct } from '@/hooks/useProduct';
import { useCart } from '@/hooks/useCart';

// Mock hooks
jest.mock('@/hooks/useProduct');
jest.mock('@/hooks/useCart');

const mockUseProduct = useProduct as jest.MockedFunction<typeof useProduct>;
const mockUseCart = useCart as jest.MockedFunction<typeof useCart>;

describe('ProductCardContainer', () => {
  const mockProduct = {
    id: '1',
    name: '테스트 상품',
    price: 10000,
    originalPrice: 15000,
    stock: 5,
    description: '테스트 설명'
  };
  
  const mockAddToCart = jest.fn();
  
  beforeEach(() => {
    mockUseProduct.mockReturnValue({
      product: mockProduct,
      isLoading: false,
      error: null
    });
    
    mockUseCart.mockReturnValue({
      addToCart: mockAddToCart,
      isAddingToCart: false
    });
  });
  
  it('상품 정보를 올바르게 표시한다', () => {
    render(<ProductCardContainer productId="1" />);
    
    expect(screen.getByText('테스트 상품')).toBeInTheDocument();
    expect(screen.getByText('10,000원')).toBeInTheDocument();
    expect(screen.getByText('33% 할인')).toBeInTheDocument();
  });
  
  it('장바구니 추가 버튼 클릭 시 addToCart가 호출된다', () => {
    render(<ProductCardContainer productId="1" />);
    
    fireEvent.click(screen.getByText('장바구니 추가'));
    
    expect(mockAddToCart).toHaveBeenCalledWith('1');
  });
  
  it('로딩 중일 때 스켈레톤을 표시한다', () => {
    mockUseProduct.mockReturnValue({
      product: null,
      isLoading: true,
      error: null
    });
    
    render(<ProductCardContainer productId="1" />);
    
    expect(screen.getByTestId('product-card-skeleton')).toBeInTheDocument();
  });
  
  it('에러 발생 시 에러 컴포넌트를 표시한다', () => {
    const error = new Error('상품을 불러올 수 없습니다');
    mockUseProduct.mockReturnValue({
      product: null,
      isLoading: false,
      error
    });
    
    render(<ProductCardContainer productId="1" />);
    
    expect(screen.getByText('상품을 불러올 수 없습니다')).toBeInTheDocument();
  });
});
```

### 2. UI 컴포넌트 테스트

```tsx
// ProductCardUI.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ProductCardUI } from './ProductCardUI';

describe('ProductCardUI', () => {
  const defaultProps = {
    name: '테스트 상품',
    price: '10,000원',
    stockStatus: 'sufficient' as const,
    remainingStock: 5,
    onAddToCart: jest.fn()
  };
  
  it('상품 정보를 올바르게 렌더링한다', () => {
    render(<ProductCardUI {...defaultProps} />);
    
    expect(screen.getByText('테스트 상품')).toBeInTheDocument();
    expect(screen.getByText('10,000원')).toBeInTheDocument();
    expect(screen.getByText('재고 충분')).toBeInTheDocument();
  });
  
  it('할인율이 있을 때 할인 배지를 표시한다', () => {
    render(
      <ProductCardUI 
        {...defaultProps} 
        originalPrice="15,000원"
        discountRate="33%"
      />
    );
    
    expect(screen.getByText('15,000원')).toBeInTheDocument();
    expect(screen.getByText('33% 할인')).toBeInTheDocument();
  });
  
  it('품절 상태일 때 버튼이 비활성화된다', () => {
    render(
      <ProductCardUI 
        {...defaultProps} 
        stockStatus="out"
      />
    );
    
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
    expect(button).toHaveTextContent('품절');
  });
  
  it('장바구니 추가 버튼 클릭 시 onAddToCart가 호출된다', () => {
    const onAddToCart = jest.fn();
    render(<ProductCardUI {...defaultProps} onAddToCart={onAddToCart} />);
    
    fireEvent.click(screen.getByText('장바구니 추가'));
    
    expect(onAddToCart).toHaveBeenCalledTimes(1);
  });
  
  it('compact variant일 때 설명이 숨겨진다', () => {
    render(
      <ProductCardUI 
        {...defaultProps} 
        description="테스트 설명"
        variant="compact"
      />
    );
    
    expect(screen.queryByText('테스트 설명')).not.toBeInTheDocument();
  });
});
```

## 마이그레이션 체크리스트

### 1. 사전 준비 및 검증
- [ ] 기존 컴포넌트의 모든 props 인터페이스 문서화
- [ ] 기존 컴포넌트의 모든 이벤트 핸들러 동작 확인
- [ ] 기존 컴포넌트의 모든 조건부 렌더링 로직 파악
- [ ] 기존 컴포넌트의 모든 스타일링 규칙 확인
- [ ] 기존 컴포넌트의 테스트 케이스 작성 (기준점 확보)

### 2. 분리 대상 식별
- [ ] 데이터 가공 로직이 있는 컴포넌트
- [ ] API 호출이나 상태 관리가 있는 컴포넌트
- [ ] 비즈니스 로직이 포함된 컴포넌트
- [ ] 조건부 렌더링 로직이 복잡한 컴포넌트

### 2. 데이터 컴포넌트 생성
- [ ] 데이터 가져오기 로직 구현
- [ ] 데이터 가공 로직 구현
- [ ] 상태 관리 로직 구현
- [ ] 에러 처리 로직 구현

### 3. UI 컴포넌트 생성
- [ ] 순수한 표현 로직만 포함
- [ ] Props 인터페이스 정의
- [ ] 조건부 렌더링 최소화
- [ ] 재사용 가능한 구조 설계

### 4. 테스트 작성
- [ ] 데이터 컴포넌트 단위 테스트
- [ ] UI 컴포넌트 단위 테스트
- [ ] 통합 테스트
- [ ] 사용자 시나리오 테스트

### 5. 리팩토링 완료
- [ ] 기존 컴포넌트 제거
- [ ] import 경로 업데이트
- [ ] 타입 정의 업데이트
- [ ] 문서 업데이트

### 6. 기존 기능 보존 검증
- [ ] 모든 기존 props가 동일하게 작동하는지 확인
- [ ] 모든 기존 이벤트 핸들러가 동일한 동작을 하는지 확인
- [ ] 모든 기존 조건부 렌더링이 동일하게 작동하는지 확인
- [ ] 모든 기존 스타일링이 동일하게 적용되는지 확인
- [ ] 기존 테스트 케이스가 모두 통과하는지 확인
- [ ] 실제 사용자 시나리오에서 동일한 결과가 나오는지 확인

## 주의사항

### 1. 기존 기능 변경 금지 ⚠️

**중요**: 컴포넌트 분리 과정에서 기존 기능이나 동작을 변경해서는 안 됩니다.

#### 금지 사항
- [ ] 기존 props 인터페이스 변경
- [ ] 기존 이벤트 핸들러 동작 변경
- [ ] 기존 스타일링 변경
- [ ] 기존 조건부 렌더링 로직 변경
- [ ] 기존 상태 관리 방식 변경

#### 올바른 분리 방법
```tsx
// ❌ 잘못된 예: 기존 기능 변경
// 기존: <ProductCard product={product} onAddToCart={handleAddToCart} />
// 변경: <ProductCard productId={product.id} onAddToCartSuccess={handleSuccess} />

// ✅ 올바른 예: 기존 인터페이스 유지
// 기존: <ProductCard product={product} onAddToCart={handleAddToCart} />
// 유지: <ProductCard product={product} onAddToCart={handleAddToCart} />

// 내부적으로만 분리
const ProductCard = ({ product, onAddToCart }: ProductCardProps) => {
  // 데이터 가공 로직
  const processedData = useMemo(() => ({
    name: product.name,
    price: formatPrice(product.price),
    // ... 기존 로직과 동일한 결과
  }), [product]);
  
  return <ProductCardUI {...processedData} onAddToCart={onAddToCart} />;
};
```

#### 점진적 마이그레이션 전략
1. **1단계**: 내부적으로만 UI/데이터 분리 (기존 인터페이스 유지)
2. **2단계**: 새로운 인터페이스 추가 (기존 인터페이스와 병행)
3. **3단계**: 사용처에서 새로운 인터페이스로 점진적 마이그레이션
4. **4단계**: 기존 인터페이스 제거 (모든 사용처 마이그레이션 완료 후)

```tsx
// 1단계: 내부 분리만 (기존 인터페이스 유지)
const ProductCard = ({ product, onAddToCart }: ProductCardProps) => {
  return <ProductCardUI {...processData(product)} onAddToCart={onAddToCart} />;
};

// 2단계: 새로운 인터페이스 추가
const ProductCard = ({ 
  product, 
  onAddToCart,
  productId, // 새로운 옵션
  ...props 
}: ProductCardProps & { productId?: string }) => {
  // 기존 로직 유지하면서 새로운 옵션 지원
  const finalProduct = productId ? useProduct(productId) : product;
  
  return <ProductCardUI {...processData(finalProduct)} onAddToCart={onAddToCart} />;
};
```

### 2. 과도한 분리 방지
```tsx
// ❌ 과도한 분리: 너무 작은 단위로 분리
const ProductName = ({ name }: { name: string }) => <h3>{name}</h3>;
const ProductPrice = ({ price }: { price: string }) => <span>{price}</span>;
const ProductButton = ({ onClick }: { onClick: () => void }) => <button onClick={onClick}>추가</button>;

// ✅ 적절한 분리: 의미 있는 단위로 분리
const ProductCard = () => {
  // 데이터 로직
  return <ProductCardUI {...data} />;
};
```

### 2. Props Drilling 방지
```tsx
// ❌ Props Drilling
const App = () => {
  const [user, setUser] = useState(null);
  return <Header user={user} />;
};

const Header = ({ user }) => <Nav user={user} />;
const Nav = ({ user }) => <UserMenu user={user} />;
const UserMenu = ({ user }) => <div>{user.name}</div>;

// ✅ Context 또는 Custom Hook 사용
const App = () => {
  return <UserProvider><Header /></UserProvider>;
};

const Header = () => <Nav />;
const Nav = () => <UserMenu />;
const UserMenu = () => {
  const { user } = useUser();
  return <div>{user.name}</div>;
};
```

### 3. 성능 최적화
```tsx
// ❌ 불필요한 리렌더링
const ProductCard = ({ productId }) => {
  const product = useProduct(productId);
  const processedData = {
    name: product.name,
    price: formatPrice(product.price),
    // 매번 새로운 객체 생성
  };
  
  return <ProductCardUI {...processedData} />;
};

// ✅ 메모이제이션 활용
const ProductCard = ({ productId }) => {
  const product = useProduct(productId);
  const processedData = useMemo(() => ({
    name: product.name,
    price: formatPrice(product.price),
  }), [product]);
  
  return <ProductCardUI {...processedData} />;
};
```

## 결론

데이터 컴포넌트 분리는 다음과 같은 이점을 제공합니다:

1. **관심사 분리**: UI와 비즈니스 로직의 명확한 분리
2. **재사용성 향상**: UI 컴포넌트의 높은 재사용성
3. **테스트 용이성**: 각 계층별 독립적인 테스트 가능
4. **유지보수성**: 코드 변경 시 영향 범위 최소화
5. **개발 생산성**: 팀원 간 역할 분담으로 개발 효율성 향상

### ⚠️ 핵심 원칙

**기존 기능은 절대 변경하지 마세요.** 컴포넌트 분리의 목적은 코드 구조 개선이지, 기능 변경이 아닙니다. 

- 모든 기존 props와 이벤트 핸들러는 동일하게 작동해야 합니다
- 모든 기존 스타일링과 조건부 렌더링은 동일하게 적용되어야 합니다
- 사용자 경험에는 어떠한 변화도 없어야 합니다

이 가이드를 따라 단계적으로 데이터 컴포넌트를 분리하여 더 나은 코드 구조를 구축하세요.
