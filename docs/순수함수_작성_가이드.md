# 순수함수 작성 가이드

## 개요
순수함수는 같은 입력에 대해 항상 같은 출력을 반환하고, 부작용(side effect)이 없는 함수입니다. 이 문서는 순수함수를 작성할 때 빠트리기 쉬운 점들을 정리한 가이드입니다.

## 1. 부작용 제거하기

### ❌ 잘못된 예시
```typescript
// 부작용이 포함된 함수
export function addToCart({
  cart,
  product,
  onSuccess,
  onFailure,
}: AddToCartParams) {
  if (checkSoldOut()) {
    onFailure({ message: '재고가 부족합니다!' }); // 부작용
    return cart;
  }
  
  onSuccess(); // 부작용
  return newCart;
}
```

### ✅ 올바른 예시
```typescript
// 순수함수로 분리
export function addToCartWithStockCheck({
  cart,
  product,
  isSoldOut,
}: AddToCartWithStockCheckParams) {
  if (isSoldOut) {
    return { 
      newCart: cart, 
      success: false, 
      message: '재고가 부족합니다!' 
    };
  }
  
  // 순수한 계산 로직만
  const newCart = calculateNewCart(cart, product);
  return { newCart, success: true, message: '장바구니에 담았습니다' };
}
```

## 2. 콜백 함수 제거하기

### ❌ 잘못된 예시
```typescript
interface AddProductParams {
  id: string;
  newProduct: Omit<ProductWithUI, 'id'>;
  products: ProductWithUI[];
  onSuccess: () => void; // 콜백 함수
}

export function addProduct({
  id,
  newProduct,
  products,
  onSuccess,
}: AddProductParams) {
  onSuccess(); // 부작용
  return [...products, { ...newProduct, id }];
}
```

### ✅ 올바른 예시
```typescript
interface AddProductParams {
  id: string;
  newProduct: Omit<ProductWithUI, 'id'>;
  products: ProductWithUI[];
}

export function addProduct({
  id,
  newProduct,
  products,
}: AddProductParams) {
  return [...products, { ...newProduct, id }];
}
```

## 3. 외부 의존성 주입받기

### ❌ 잘못된 예시
```typescript
// 외부 함수를 직접 호출
export function formatPrice({ cart, product }: FormatPriceParams) {
  const soldOut = isSoldOut({
    getRemainingStock: () => getRemainingStock({ cart, product }),
  });
  return soldOut ? 'SOLD OUT' : formatter({ number: product.price });
}
```

### ✅ 올바른 예시
```typescript
// 의존성을 명시적으로 주입받기
interface FormatPriceParams {
  cart: CartItem[];
  product: Product;
  formatter: (params: { number: number }) => string;
  isSoldOut: (params: { remainingStock: number }) => boolean;
  getRemainingStock: (params: { cart: CartItem[], product: Product }) => number;
}

export function formatPrice({ 
  cart, 
  product, 
  formatter, 
  isSoldOut, 
  getRemainingStock 
}: FormatPriceParams) {
  const remainingStock = getRemainingStock({ cart, product });
  const soldOut = isSoldOut({ remainingStock });
  return soldOut ? 'SOLD OUT' : formatter({ number: product.price });
}
```

## 4. 결과 객체로 상태와 메시지 반환하기

### ❌ 잘못된 예시
```typescript
// 성공/실패를 콜백으로 처리
export function addCoupon({
  newCoupon,
  coupons,
  onFailure,
  onSuccess,
}: AddCouponParams) {
  const existingCoupon = coupons.find(c => c.code === newCoupon.code);
  
  if (existingCoupon) {
    onFailure({ message: '이미 존재하는 쿠폰 코드입니다.' });
    return coupons;
  }
  
  onSuccess();
  return [...coupons, newCoupon];
}
```

### ✅ 올바른 예시
```typescript
// 결과 객체로 상태와 메시지 반환
export function addCoupon({
  newCoupon,
  coupons,
}: AddCouponParams) {
  const existingCoupon = coupons.find(c => c.code === newCoupon.code);
  
  if (existingCoupon) {
    return { 
      newCoupons: coupons, 
      success: false, 
      message: '이미 존재하는 쿠폰 코드입니다.' 
    };
  }
  
  const newCoupons = [...coupons, newCoupon];
  return { newCoupons, success: true, message: '쿠폰이 추가되었습니다' };
}
```

## 5. 훅에서 부작용 처리하기

### ❌ 잘못된 예시
```typescript
// 훅에서 모델 함수에 콜백 전달
const addToCart = useCallback(({ product }) => {
  setCart((prevCart) => {
    return cartModel.addToCart({
      cart: prevCart,
      product,
      onSuccess: () => notify({ message: '장바구니에 담았습니다', type: 'success' }),
      onFailure: ({ message }) => notify({ message, type: 'error' }),
    });
  });
}, [setCart, notify]);
```

### ✅ 올바른 예시
```typescript
// 훅에서 순수함수 호출 후 부작용 처리
const addToCart = useCallback(({ product }) => {
  setCart((prevCart) => {
    const remainingStock = productModel.getRemainingStock({ cart: prevCart, product });
    const isSoldOut = productModel.isSoldOut({ remainingStock });
    
    const result = cartModel.addToCartWithStockCheck({
      cart: prevCart,
      product,
      isSoldOut,
    });
    
    // 부작용은 훅에서 처리
    if (!result.success) {
      notify({ message: result.message, type: 'error' });
      return prevCart;
    }
    
    notify({ message: result.message, type: 'success' });
    return result.newCart;
  });
}, [setCart, notify]);
```

## 6. 검증 로직을 순수함수로 분리하기

### ❌ 잘못된 예시
```typescript
// 검증 로직이 훅에 섞여있음
const updateQuantity = useCallback(({ productId, newQuantity, products }) => {
  setCart((prevCart) => {
    if (newQuantity <= 0) {
      return removeItemFromCart({ cart: prevCart, productId });
    }
    
    const product = products.find(p => p.id === productId);
    if (!product) return prevCart;
    
    if (newQuantity > product.stock) {
      notify({ message: `재고는 ${product.stock}개까지만 있습니다.`, type: 'error' });
      return prevCart;
    }
    
    notify({ message: '수량이 변경되었습니다', type: 'success' });
    return updateCartItemQuantity({ cart: prevCart, productId, quantity: newQuantity });
  });
}, [setCart, notify]);
```

### ✅ 올바른 예시
```typescript
// 검증 로직을 순수함수로 분리
export function updateCartQuantityWithValidation({
  cart,
  products,
  productId,
  newQuantity,
}: UpdateCartQuantityWithValidationParams) {
  if (newQuantity <= 0) {
    const newCart = removeItemFromCart({ cart, productId });
    return { newCart, success: true, message: '상품이 제거되었습니다' };
  }
  
  const product = products.find(p => p.id === productId);
  if (!product) {
    return { newCart: cart, success: false, message: '상품을 찾을 수 없습니다' };
  }
  
  if (newQuantity > product.stock) {
    return { 
      newCart: cart, 
      success: false, 
      message: `재고는 ${product.stock}개까지만 있습니다.` 
    };
  }
  
  const newCart = updateCartItemQuantity({ cart, productId, quantity: newQuantity });
  return { newCart, success: true, message: '수량이 변경되었습니다' };
}

// 훅에서는 순수함수 호출만
const updateQuantity = useCallback(({ productId, newQuantity, products }) => {
  setCart((prevCart) => {
    const result = cartModel.updateCartQuantityWithValidation({
      cart: prevCart,
      newQuantity,
      productId,
      products,
    });
    
    if (!result.success) {
      notify({ message: result.message, type: 'error' });
      return prevCart;
    }
    
    notify({ message: result.message, type: 'success' });
    return result.newCart;
  });
}, [setCart, notify]);
```

## 7. 타입 안전성 확보하기

### ❌ 잘못된 예시
```typescript
// 타입이 불분명한 결과
export function applyCoupon({ coupon, prevCoupon, cartTotal }: ApplyCouponParams) {
  if (cartTotal < 10_000 && coupon.discountType === 'percentage') {
    return prevCoupon; // 타입이 불분명
  }
  return coupon;
}
```

### ✅ 올바른 예시
```typescript
// 명확한 타입 정의
interface ApplyCouponResult {
  selectedCoupon: Coupon | null;
  success: boolean;
  message: string;
}

export function applyCoupon({ coupon, prevCoupon, cartTotal }: ApplyCouponParams): ApplyCouponResult {
  if (cartTotal < 10_000 && coupon.discountType === 'percentage') {
    return { 
      selectedCoupon: prevCoupon, 
      success: false, 
      message: 'percentage 쿠폰은 10,000원 이상 구매 시 사용 가능합니다.' 
    };
  }
  
  return { selectedCoupon: coupon, success: true, message: '쿠폰이 적용되었습니다' };
}
```

## 8. 테스트하기 쉬운 구조 만들기

### ❌ 잘못된 예시
```typescript
// 테스트하기 어려운 구조
export function addToCart({ cart, product, checkSoldOut, onSuccess, onFailure }: AddToCartParams) {
  if (checkSoldOut()) {
    onFailure({ message: '재고가 부족합니다!' });
    return cart;
  }
  onSuccess();
  return newCart;
}
```

### ✅ 올바른 예시
```typescript
// 테스트하기 쉬운 구조
export function addToCartWithStockCheck({ cart, product, isSoldOut }: AddToCartWithStockCheckParams) {
  if (isSoldOut) {
    return { newCart: cart, success: false, message: '재고가 부족합니다!' };
  }
  
  const newCart = addItemToCart({ cart, product });
  return { newCart, success: true, message: '장바구니에 담았습니다' };
}

// 테스트 예시
describe('addToCartWithStockCheck', () => {
  it('재고가 부족하면 실패를 반환한다', () => {
    const result = addToCartWithStockCheck({
      cart: [],
      product: { id: '1', stock: 0, ... },
      isSoldOut: true,
    });
    
    expect(result.success).toBe(false);
    expect(result.message).toBe('재고가 부족합니다!');
  });
});
```

## 9. 함수 분리 원칙

### ❌ 잘못된 예시
```typescript
// 하나의 함수가 여러 역할을 수행
export function processCart({ cart, product, notify, setCart, ... }) {
  // 검증
  if (isSoldOut()) { ... }
  
  // 계산
  const newCart = calculateNewCart(cart, product);
  
  // 부작용
  setCart(newCart);
  notify({ message: '성공!', type: 'success' });
  
  return newCart;
}
```

### ✅ 올바른 예시
```typescript
// 각 역할별로 함수 분리
// 1. 검증 함수
export function validateAddToCart({ cart, product, isSoldOut }: ValidateParams) {
  if (isSoldOut) {
    return { isValid: false, message: '재고가 부족합니다!' };
  }
  return { isValid: true, message: '검증 통과' };
}

// 2. 계산 함수
export function calculateNewCart({ cart, product }: CalculateParams) {
  return addItemToCart({ cart, product });
}

// 3. 훅에서 조합
const addToCart = useCallback(({ product }) => {
  const validation = validateAddToCart({ cart, product, isSoldOut });
  if (!validation.isValid) {
    notify({ message: validation.message, type: 'error' });
    return;
  }
  
  const newCart = calculateNewCart({ cart, product });
  setCart(newCart);
  notify({ message: '장바구니에 담았습니다', type: 'success' });
}, [cart, setCart, notify]);
```

## 10. 체크리스트

순수함수를 작성할 때 다음 사항들을 확인하세요:

- [ ] **부작용이 있는가?** (콘솔 로그, 알림, 상태 변경 등)
- [ ] **콜백 함수를 사용하는가?** (onSuccess, onFailure 등)
- [ ] **외부 함수를 직접 호출하는가?** (의존성 주입이 필요한가?)
- [ ] **결과가 명확한가?** (타입이 분명한가?)
- [ ] **테스트하기 쉬운가?** (입력과 출력이 명확한가?)
- [ ] **재사용 가능한가?** (다른 곳에서도 사용할 수 있는가?)
- [ ] **단일 책임 원칙을 지키는가?** (하나의 함수가 하나의 역할만 하는가?)

## 결론

순수함수를 작성할 때 가장 중요한 것은 **부작용을 제거하고, 모든 필요한 데이터를 파라미터로 전달받으며, 명확한 결과를 반환하는 것**입니다. 이를 통해 코드의 예측 가능성, 테스트 용이성, 재사용성을 크게 향상시킬 수 있습니다.
